---
layout: post
title: "Dubbo SPI"
date: 2020-01-10T06:11:50.030Z
categories: Dubbo
---

Dubbo SPI扩展机制

## 概述

SPI 全称为 Service Provider Interface，是一种服务发现机制。SPI 的本质是将接口实现类的全限定名配置在文件中，并由服务加载器读取配置文件，加载实现类。

> duubo 版本

```xml
<dependency>
    <groupId>org.apache.dubbo</groupId>
    <artifactId>dubbo</artifactId>
    <version>2.7.4.1</version>
</dependency>
```

## SPI示例

### Java SPI示例

> 定义一个接口

```java
package axx.spi;

import org.apache.dubbo.common.extension.SPI;

/**
 * create on 2019-12-26 by gaoxinzhong
 **/
@SPI // dubbo spi 需要的注解。
public interface Robot {

    void sayHello();
}
```

> 定义2个实现类Bumblebee和OptimusPrime

```java
package axx.spi.java;

import axx.spi.Robot;

/**
 * create on 2019-12-26 by gaoxinzhong
 **/
public class Bumblebee implements Robot {

    @Override
    public void sayHello() {
        System.out.println("Hello, I am Bumblebee.");
    }
}

package axx.spi.java;

import axx.spi.Robot;

/**
 * create on 2019-12-26 by gaoxinzhong
 **/
public class OptimusPrime implements Robot {

    @Override
    public void sayHello() {
        System.out.println("Hello, I am Optimus Prime.");
    }
}
```

> 在resource目录下，创建/META-INF/services/axx.spi.Robot文件，内容如下

```java
axx.spi.java.Bumblebee
axx.spi.java.OptimusPrime
```

> 测试类

```java
package axx.spi;

import org.junit.Test;

import java.util.ServiceLoader;

/**
 * Unit test for simple SpiTest.
 */
public class SpiTest {

    @Test
    public void testJavaSpiTest() {
        ServiceLoader<Robot> serviceLoader = ServiceLoader.load(Robot.class);
        serviceLoader.forEach(Robot::sayHello);
    }
}
```

> 源码解读

- 第一行代码，创建一个serviceLoader实例，此时没有加载任何接口实现类的操作，看下serviceLoader里几个属性：

```java
public void reload() {
    providers.clear(); 
    lookupIterator = new LazyIterator(service, loader);
}

private ServiceLoader(Class<S> svc, ClassLoader cl) {
    service = Objects.requireNonNull(svc, "Service interface cannot be null");
    loader = (cl == null) ? ClassLoader.getSystemClassLoader() : cl;
    acc = (System.getSecurityManager() != null) ? AccessController.getContext() : null;
    reload();
}

// 实现类存储的目录
private static final String PREFIX = "META-INF/services/";

// 加载的接口
private final Class<S> service;

// The class loader used to locate, load, and instantiate providers
private final ClassLoader loader;

// The access control context taken when the ServiceLoader is created
private final AccessControlContext acc;

// 用于缓存已经加载接口的实现类，其中key为类的全限定名
private LinkedHashMap<String,S> providers = new LinkedHashMap<>();

// 延迟加载接口的实现类
private LazyIterator lookupIterator;
```
- serviceLoader实现了iterator接口，forEach的过程就是hasNex()和next()的过程，实际是调用LazyIterator实现类的hasNext()和next()，但实现类内部又是调用hasNextService()和nextService()。

```java
public Iterator<S> iterator() {
        return new Iterator<S>() {

            Iterator<Map.Entry<String, S>> knownProviders
                    = providers.entrySet().iterator();

            public boolean hasNext() {
                if (knownProviders.hasNext())
                    return true;
                return lookupIterator.hasNext(); 
            }

            public S next() {
                if (knownProviders.hasNext())
                    return knownProviders.next().getValue();
                return lookupIterator.next();
            }

            public void remove() {
                throw new UnsupportedOperationException();
            }

        };
    }

// 第一个实现类会解析文件内容，并存储到pending。
private boolean hasNextService() {
    if (nextName != null) {
        return true;
    }
    if (configs == null) {
        try {
            // 文件路径
            String fullName = PREFIX + service.getName();
            if (loader == null)
                configs = ClassLoader.getSystemResources(fullName);
            else
                configs = loader.getResources(fullName);
        } catch (IOException x) {
            fail(service, "Error locating configuration files", x);
        }
    }
    while ((pending == null) || !pending.hasNext()) {
        if (!configs.hasMoreElements()) {
            return false;
        }
        // 解析内容
        pending = parse(service, configs.nextElement());
    }
    nextName = pending.next(); // 实现类全路径。
    return true;
}

// 根据nextName（类全路径），通过反射加载该实现类。
private S nextService() {
    if (!hasNextService())
        throw new NoSuchElementException();
    String cn = nextName;
    nextName = null; 
    Class<?> c = null;
    try {
        c = Class.forName(cn, false, loader);
    } catch (ClassNotFoundException x) {
        fail(service,
             "Provider " + cn + " not found");
    }
    if (!service.isAssignableFrom(c)) {
        fail(service,
             "Provider " + cn  + " not a subtype");
    }
    try {
        // 反射
        S p = service.cast(c.newInstance());
        // 缓存providers key 类全路径 value 实例
        providers.put(cn, p);
        return p;
    } catch (Throwable x) {
        fail(service,
             "Provider " + cn + " could not be instantiated",
             x);
    }
    throw new Error();          // This cannot happen
}
```

### Java SPI应用

- mysql

```java
com.mysql.jdbc.Driver
com.mysql.fabric.jdbc.FabricMySQLDriver
```

### Java SPI总结

- 获取实现类的方式不够灵活，只能通过iterator遍历，接口的实现类全部被加载。如果不想使用某个实现类，其实也是被加载了，资源浪费。
