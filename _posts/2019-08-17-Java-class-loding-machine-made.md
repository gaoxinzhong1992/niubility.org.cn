---
layout: post
title: "Java类加载机制"
date: 2019-08-17 10:51:51
categories: Java
---

类加载机制

## 0.java内存模型

![jvm内存模型](https://niubility.org.cn/assets/images/jvm20190819.png)

## 1.什么是类的加载？

Java虚拟机把描述类的数据从class文件中加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的的Java类型，这就是虚拟机的加载机制。class文件由类的装载器装载后，在JVM中将形成一份描述class结构的元信息对象，通过该元信息对象可以获取class的结构信息：如构造函数，属性和方法等，Java允许用户借由这个class相关的元信息对象间接调用class对象的功能。

## 2.类的加载过程

![java类加载过程](https://niubility.org.cn/assets/images/jvm201908191.png)

类的加载过程包括加载、验证、准备、解析、初始化五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是相互交叉地混合进行的，通常在一个阶段执行的过程调用或激活另一个阶段。

### 2.1 加载 - 查找和加载class文件

查找并加载类的二进制数据(```.class```)是类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：

- 0.通过一类的全限定名来获取其定义的二进制字节流。
- 1.将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构。
- 2.在Java堆中生成一个代表这个类的```java.lang.Class```对象，作为堆方法区中这些数据的入口。

> 注意：二进制字节流并不只是单纯的从class文件中获取，比如它还可以从jar包中获取，从网络中获取（最典型的应用就是Applet)，由其他文件生成（jsp文件）等。

相对于类加载的其他阶段而言，在加载阶段（准确的说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。

加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个```java.lang.Class```类的对象，这样便可以通过该对象访问方法区中的这些数据。

> TODO 类加载器

### 2.2 验证 - 检查加载的class文件数据的正确性

验证的目的是为了确保class文件中的字节流包含的信息符合当前虚拟机的要求，而且不会危害虚拟机自身的安全。不同虚拟机对类验证的实现可能会有所不同，但大致都会完成一下四个阶段的验证：```文件格式、元数据、字节码和符号引用```

- **文件格式**：验证字节流是否符合class文件格式的规范，并且能被当前版本的虚拟机处理，该验证的主要目的是确保输入的字节流能正确的解析并存储于方法区之内。经过该阶段的验证后，字节流才会进入内存的方法区中进行存储，后面的三个验证都是基于方法区的存储结构进行的。
- **元数据**：对类的元数据信息进行语义校验（其实就是对类中的各数据类型进行语法校验），确保不存在不符合Java语法规范的元数据信息。
- **字节码**：该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机的安全行为。
- **符号引用**：这是最后一个阶段的验证，它发生在虚拟机将符号引用转化为直接引用的时候（解析阶段中发生该转化，下文会讲解），主要是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验。

> 验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用```-Xverifynone```参数来关闭大部分类的验证措施，以缩短虚拟机类加载时间。

### 2.3 准备 - 为类的静态变量分配内存，并将其初始为默认值

准备阶段正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：

- 0.此时进行内存分配的仅包括类变量（```static```），而不包括实例变量，实例变量会在对象实例化时随对象一块分配在Java堆中。
- 1.这里所设置的初始值通常情况下是数据类型默认的零值（如0，0L，null，false等），而不是被Java代码中显示的赋予的值。

假设一个类变量的定义为：```public static int value = 3;```

那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的```public static```指令是在程序编译后，存放于类构造器```<clinit>()```方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。

> Java中所有的基本数据类型以及reference类型的默认零值：

![数据类型及默认值](https://niubility.org.cn/assets/images/jvm201908193.png)

> 这里还需要注意一下几点：
- 对基本数据类型、类变量（```static```）和全局变量，如果不显示地赋值而直接使用，则系统会为其赋予默认零值，而对于局部变量来说，在使用前必须显示地为其赋值，否则编译时不通过。
- 对于同时被static和final修饰的常量，必须在声明时就为其显示地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显示的为其赋值，也可以在类初始化时显示地为其赋值，总之，在使用前必须为其显示地赋值，系统不会为其赋予默认零值。
- 对于引用数据类型reference来说，如数组，对象引用等，如果没有对其进行显示地赋值而直接使用，系统都会为其默认赋予默认零值，即null。
- 如果数组在初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认零值。

- 2.如果类字段的字段属性表中存放在```ConstantValue```属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为```ConstantValue```属性所指定的值。

假设上面的类变量value被定义为：```public staitc final int value = 3;```

编译时Javac将会为value生成```ConstantValue```属性，在准备阶段虚拟机根据```ConstantValue```的设置将value赋值为3。```我们可以理解为static final常量在编译期就将其结果放入了调用它的类的常量池中。```

### 2.4 解析 - 把类中的符号引用转换为直接引用

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。符号引用就是一组符号来描述目标，可以是任何字面量。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。

对同一个符号引用进行多次解析请求时很常见的事情，虚拟机实现可能会对第一次解析的结果进行缓存（在运行时常量池中记录直接引用，并把常量标示为已解析状态），从而避免解析动作重复进行。

解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行，分别对应于常量池中的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info四种常量类型。

- **0.类或接口解析**：判断所要转化成的直接引用是对数组类型，还是普通的对象类型的引用，从而进行不同的解析。
- **1.字段解析**：会先在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有，则查找结束；如果没有，则会按照继承关系从上往下递归搜索该类所实现的各个接口和它们的父接口，还没有，则按照继承关系从上往下递归搜索其父类，直至查找结束，查找流程如下图所示：
![字段解析搜索流程](https://niubility.org.cn/assets/images/jvm201908192.png)

```
class Super {
    public static int value = 5;
    static {
        System.out.println("执行了super类静态代码语句块");
    }
}

class Father extends Super {
   public static int value = 6;
   static {
       System.out.println("执行了father类静态代码语句块");
   }
}

class Child extends Father {
    static {
        System.out.println("执行了child类静态代码语句块");
    }
}

public class StaticTest {
    public static void main(String [] args) {
        System.out.println(Child.m);
    }
}
```

执行结果如下：
- 执行了super类静态代码语句块
- 执行了father类静态代码语句块
- 6

如果注释掉father类中对value定义的那一行，则输出结果如下：
- 执行了super类静态代码语句块
- 5

分析如下：
> static变量发生在静态解析阶段，也即是初始化之前，此时已经将字段的符号引用转化为了内存引用，也便将它与对应的类关联在了一起，由于在子类中没有查找到与value相匹配的字段，那么value便不会与子类关联在一起，因此并不会触发子类的初始化。

- **2.类方法解析**：对类方法的解析于对字段解析的搜索步骤差不多，只是多了判断方法所处的是类还是接口的步骤，而且对类方法的匹配索索，实现搜索父类在搜索接口。
- **3.接口方法解析**：于类方法解析步骤类似，只是接口不会有父类，因此只递归搜索父接口就行。

### 2.5 初始化 - 类的静态变量，静态代码块执行初始化

初始化是类加载过程的最后一步，到了此阶段，才真正开始执行类定义中的Java程序代码。在准备阶段，类变量已经被赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序指定的主观计划去初始化类变量和其他资源，或者可以从另一个角度表达：初始化阶段是执行类构造器```<clinit>()```方法的过程。

简单说明下```<clinit>()```方法执行规则

- 0.```<clinit>()```方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块中可以赋值，但不能访问。
- 1.```<clinit>()```与实例构造器```<init>()```方法（类的构造函数）不同，它不需要显示的调用父类构造器，虚拟机会保证在子类的```<clinit>()```方法执行之前，父类的```<clinit>()```方法已经执行完毕。因此，在虚拟机中第一个被执行```<clinit>()```方法的类肯定是```java.lang.Object```。
- 3.```<clinit>()```方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成```<clinit>()```方法。
- 4.接口中不能使用静态语句块，但仍然有类变量（final static）初始化的赋值操作，因此接口与类一样会生成```<clinit>()```方法。但是接口与类不同的是：执行接口的```<clinit>()```方法不需要先执行父接口的```<clinit>()```方法，只有当父接口中定义的变量被使用时，父接口才会被初始化。另外接口的实现在初始化也一样不会执行接口的```<clinit>()```方法。
- 5.虚拟机会保证一个类的```<clinit>()```方法在多线程环境中被正确的加锁和同步，如果个多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的```<clinit>()```方法，其他线程需要阻塞等待，直到活动线程执行```<clinit>()```方法完毕。如果在一个类的```<clinit>()```方法中有耗时很长的操作，那么就可能造成多个线程阻塞，在实际应用中这种阻塞往往是很隐蔽的。

给出一个简单的例子：

```
class Father {
    public static int value = 1;
    static {
        value = 2;
    }
}

class Child extends Father {
    public static int copyValue = value;
}

public class ClinitTest {
    public static void main(String [] args) {
        System.out.println(Child.copyValue);
    }
}
```

执行上面的代码，会打印出2，也就是说b的值被赋为了2。

我们来看得到该结果的步骤。

首先在准备阶段为类变量分配内存并设置类变量初始值，这样value和copyValue均被赋值为默认值0，而后再在调用```<clinit>（）```方法时给他们赋予程序中指定的值。当我们调用Child.copyValue时，触发Child的```<clinit>（）```方法，根据规则2，在此之前，要先执行完其父类Father的```<clinit>（）```方法，又根据规则1，在执行```<clinit>（）```方法时，需要按static语句或static变量赋值操作等在代码中出现的顺序来执行相关的static语句，因此当触发执行Father的```<clinit>（）```方法时，会先将value赋值为1，再执行static语句块中语句，将value赋值为2，而后再执行Child类的```<clinit>（）```方法，这样便会将copyValue的赋值为2.

如果我们颠倒一下Father类中```public static int value = 1;```语句和```static语句块```的顺序，程序执行后，则会打印出1。很明显是根据规则1，执行Father的```<clinit>（）```方法时，根据顺序先执行了static语句块中的内容，后执行了```public static int value = 1;```语句。

另外，在颠倒二者的顺序之后，如果在static语句块中对value进行访问（比如将value赋给某个变量），在编译时将会报错，因为根据规则1，它只能对value进行赋值，而不能访问。

## 总结

整个类加载过程中，除了在加载阶段用户应用程序可以自定义类加载器参与外，其余所有的动作完全由虚拟机主导和控制。到了初始化才开始执行类中定义的Java程序代码（亦字节码），但这里的执行代码只是个开端，它仅限于```<clinit>()```方法。类加载过程主要是将class文件（准确地讲，应该是类的二进制字节流）加载到虚拟机内存中，真正执行字节码的操作，在加载完成后才真正开始。