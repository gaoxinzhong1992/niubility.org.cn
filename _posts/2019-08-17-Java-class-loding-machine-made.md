---
layout: post
title: "Java类加载机制"
date: 2019-07-17 10:51:51
categories: Java
---

## 0.java内存模型

![jvm内存模型](https://niubility.org.cn/assets/images/jvm20190819.png)

## 1.什么是类的加载？

Java虚拟机把描述类的数据从class文件中加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的的Java类型，这就是虚拟机的加载机制。class文件由类的装载器装载后，在JVM中将形成一份描述class结构的元信息对象，通过该元信息对象可以获取class的结构信息：如构造函数，属性和方法等，Java允许用户借由这个class相关的元信息对象间接调用class对象的功能。

## 2.类的加载过程

![java类加载过程](https://niubility.org.cn/assets/images/jvm201908191.png)

类的加载过程包括加载、验证、准备、解析、初始化五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是相互交叉地混合进行的，通常在一个阶段执行的过程调用或激活另一个阶段。

### 2.1 加载 - 查找和加载class文件

查找并加载类的二进制数据(```.class```)是类加载过程的第一个阶段，在加载阶段，虚拟机需要完成一下三件事情：

- 0.通过一类的全限定名来获取其定义的二进制字节流。
- 1.将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构。
- 2.在Java堆中生成一个代表这个类的```java.lang.Class```对象，作为堆方法区中这些数据的入口。

> 注意：二进制字节流并不只是单纯的从class文件中获取，比如它还可以从jar包中获取，从网络中获取（最典型的应用就是Applet)，由其他文件生成（jsp文件）等。

相对于类加载的其他阶段而言，在加载阶段（准确的说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。

加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个```java.lang.Class```类的对象，这样便可以通过该对象访问方法区中的这些数据。

> TODO 类加载器

### 2.2 验证 - 检查加载的class文件数据的正确性

验证的目的是为了确保class文件中的字节流包含的信息符合当前虚拟机的要求，而且不会危害虚拟机自身的安全。不同虚拟机对类验证的实现可能会有所不同，但大致都会完成一下四个阶段的验证：```文件格式、元数据、字节码和符号引用```

- 文件格式：验证字节流是否符合class文件格式的规范，并且能被当前版本的虚拟机处理，该验证的主要目的是确保输入的字节流能正确的解析并存储于方法区之内。经过该阶段的验证后，字节流才会进入内存的方法区中进行存储，后面的三个验证都是基于方法区的存储结构进行的。
- 元数据：对类的元数据信息进行语义校验（其实就是对类中的各数据类型进行语法校验），确保不存在不符合Java语法规范的元数据信息。
- 字节码：该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机的安全行为。
- 符号引用：这是最后一个阶段的验证，它发生在虚拟机将符号引用转化为直接引用的时候（解析阶段中发生该转化，下文会讲解），主要是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验。

> 验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用```-Xverifynone```参数来关闭大部分类的验证措施，以缩短虚拟机类加载时间。

### 2.3 准备 - 为类的静态变量分配内存，并将其初始为默认值

准备阶段正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有一下几点需要注意：

- 0.此时进行内存分配的仅包括类变量（```static```），而不包括实例变量，实例变量会在对象实例化时随对象一块分配在Java堆中。
- 1.这里所设置的初始值通常情况下是数据类型默认的零值（如0，0L，null，false等），而不是被Java代码中显示的赋予的值。

假设一个类变量的定义为：```public static int value = 3;```

那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的```public static```指令是在程序编译后，存放于类构造器```<clinit>()```方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。

> 这里还需要注意一下几点：

- 对基本数据类型、类变量（```static```）和全局变量，如果不显示地赋值而直接使用，则系统会为其赋予默认零值，而对于局部变量来说，在使用前必须显示地为其赋值，否则编译时不通过。
- 对于同时被static和final修饰的常量，必须在声明时就为其显示地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显示的为其赋值，也可以在类初始化时显示地为其赋值，总之，在使用前必须为其显示地赋值，系统不会为其赋予默认零值。
- 对于引用数据类型reference来说，如数组，对象引用等，如果没有对其进行显示地赋值而直接使用，系统都会为其默认赋予默认零值，即null。
- 如果数组在初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认零值。

- 2.如果类字段的字段属性表中存放在```ConstantValue```属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为```ConstantValue```属性所指定的值。

假设上面的类变量value被定义为：```public staitc final int value = 3;```

编译时Javac将会为value生成```ConstantValue```属性，在准备阶段虚拟机根据```ConstantValue```的设置将value赋值为3。```我们可以理解为static final常量在编译期就将其结果放入了调用它的类的常量池中。```

### 2.4 解析 - 把类中的符号引用转换为直接引用








